""" Vn={S, D, F}. Vt = {a, b, c, d}

    S-> aS / bS / cD
    D -> dD / bF / a
    F -> bS / a  /    """

rls = {"S": ["aS", "bS", "cD"],
       "D": ["dD", "bF", "a"],
       "F": ["bS", "a"]}


"""This function forms one basic word following the path of one
key in the production rules. The start key is always S."""
def form_word(letter, int_str):
    temp_str = ""
    for ind in range(len(int_str)):
        if letter in int_str[ind]:
            try:
                temp_str += str(rls[letter][ind])
            except:
                temp_str += str(rls[letter][ind - 1])
        else:
            temp_str += str(int_str[ind])

    if temp_str.__contains__("S") or temp_str.__contains__("D") or temp_str.__contains__("F"):
        for letter in temp_str:
            if letter.isupper():
                return form_word(letter, temp_str)
    else:
        return temp_str


"""This function takes a word, reduces duplicate
neighbor-characters and returns the result."""
def reduce_duplicates():
    test = input("Write a word: ")

    temp_test = test[0]

    for char in test:
        if char != temp_test[-1]:
            temp_test += char
    return temp_test


"""This list holds all the basic combinations generated by the form_word() function."""
basic = []
for key in rls.keys():
    basic.append(form_word("S", key))

"""If the tested word is reduced to a word that matches the ones in basic, it's accepted,
otherwise, the user is asked to re-insert a word."""
if reduce_duplicates() in basic:
    print("Accepted ")
else:
    print("Rejected")
    print("Available basic combinations: ", basic)
    ans = input("Would you like to retry?\nyes / no\n")
    if ans == "yes":
        reduce_duplicates()
    elif ans == "no":
        print("Ok.")
    else:
        print("Error")
